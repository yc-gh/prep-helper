{
    "name": "DSA Top 150",
    "topics": [
      {
        "name": "Arrays",
        "questions": [
          {
            "question": "Merge Sorted Array",
            "link": "https://leetcode.com/problems/merge-sorted-array/",
            "hints": "Start from the rear of both arrays and compare the elements.\nPlace the larger element at the end of the first array.",
            "code": "var merge = function(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n\n    while(i >= 0 && j >= 0) {\n        if(nums1[i] > nums2[j]) {\n            nums1[k--] = nums1[i--];\n        }\n        else {\n            nums1[k--] = nums2[j--];\n        }\n    }\n\n    while(i >= 0) {\n        nums1[k--] = nums1[i--];\n    }\n\n    while(j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Remove Element",
            "link": "https://leetcode.com/problems/remove-element/",
            "hints": "Use two pointers.\nOne to iterate the array and the other to keep track of the position to place the next element.",
            "code": "var removeElement = function(nums, val) {\n    let k = 0, i = 0, n = nums.length;\n\n    while(i < n) {\n        if(nums[i] !== val) {\n            nums[k++] = nums[i];\n        }\n        i++;\n    }\n\n    return k;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Remove Duplicates from Sorted Array",
            "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
            "hints": "Use two pointers.\nOne to iterate the array and the other to keep track of the position to place the next element (eg. k).\nIf the current element is different from the element at k, place the current element at the second pointer and increment the second pointer.",
            "code": "var removeDuplicates = function(nums) {\n    let k = 0;\n    const n = nums.length;\n\n    for(let i = 1; i < n; i++) {\n        if(nums[i] !== nums[k]) {\n            nums[++k] = nums[i];\n        }\n    }\n\n    return k + 1;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Remove Duplicates from Sorted Array II",
            "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/",
            "hints": "Similar to Remove Duplicates from Sorted Array, add an additional OR check so that values are copied only if value at k index is not equal to value at k - 1 index.",
            "code": "var removeDuplicates = function(nums) {\n    const n = nums.length;\n    let k = 0;\n\n    for(let i = 1; i < n; i++) {\n        if(nums[i] !== nums[k] || nums[k] !== nums[k-1]) {\n            nums[++k] = nums[i];\n        }\n    }\n\n    return k + 1;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Majority Element",
            "link": "https://leetcode.com/problems/majority-element/",
            "hints": "Use Boyer-Moore Voting Algorithm.\nInitialize a counter and a candidate element.\nIterate through the array and if the counter is 0, update the candidate element.\nIf the current element is the same as the candidate element, increment the counter, else decrement the counter.\nReturn the candidate element.",
            "code": "var majorityElement = function(nums) {\n    const n = nums.length;\n    let majElement = nums[0], votes = 0;\n\n    for(let i = 0; i < n; i++) {\n        if(votes === 0) {\n            majElement = nums[i];\n        }\n        \n        if(nums[i] === majElement) {\n            votes++;\n        }\n        else {\n            votes--;   \n        }\n    }\n\n    return majElement;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Rotate Array",
            "link": "https://leetcode.com/problems/rotate-array/",
            "hints": "Normalize the value of k since n * k rotation is the same as k rotation.\nReverse the entire array.\nReverse the first k elements.\nReverse the remaining elements.",
            "code": "var rotate = function(nums, k) {\n    const n = nums.length;\n    const normalisedK = k % n;\n\n    const reverse = function (from, to) {\n        let i = from, j = to;\n        while(i < j) {\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n            i++;\n            j--;\n        }\n    }\n\n    reverse(0, n - 1);\n    reverse(0, normalisedK - 1);\n    reverse(normalisedK, n - 1);\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Best Time to Buy and Sell Stock",
            "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
            "hints": "Keep track of the minimum price and the maximum profit.\nIterate through the array and update the minimum price and maximum profit.",
            "code": "var maxProfit = function(prices) {\n    let buy = prices[0], profit = 0;\n\n    for(const price of prices) {\n        if (price < buy) {\n            buy = price;\n        }\n        else if (price > buy) {\n            profit = Math.max(profit, price - buy);\n        }\n    }\n\n    return profit;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Best Time to Buy and Sell Stock II",
            "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/",
            "hints": "Iterate through the array and if the current price is greater than the previous price, add the difference to the profit.",
            "code": "var maxProfit = function(prices) {\n    let buy = prices[0], profit = 0;\n\n    for(const price of prices) {\n        if (price < buy) {\n            buy = price;\n        }\n        if (price > buy) {\n            profit += price - buy;\n            buy = price;\n        }\n    }\n\n    return profit;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Jump Game",
            "link": "https://leetcode.com/problems/jump-game/",
            "hints": "Iterate through the array and keep track of the maximum jump.\nIf the maximum jump is less than the current index, return false.\nIf the maximum jump is greater than the last index, return true.",
            "code": "var canJump = function(nums) {\n    let maxJump = 0;\n\n    for(let i = 0; i < nums.length; i++) {\n        if(maxJump < i) {\n            return false;\n        }\n        maxJump = Math.max(maxJump, i + nums[i]);\n    }\n\n    return maxJump >= nums.length - 1;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Jump Game II",
            "link": "https://leetcode.com/problems/jump-game-ii/",
            "hints": "Iterate through the array and keep track of the maximum jump.\nIf the current index is equal to the maximum jump, increment the jump count and update the maximum jump.",
            "code": "var jump = function(nums) {\n    const n = nums.length;\n    let i = 0, jumps = 0, maxEnd = 0, currEnd = 0;\n\n    for(let i = 0; i < n - 1; i++) {\n        maxEnd = Math.max(maxEnd, i + nums[i]);\n        if(i === currEnd) {\n            jumps++;\n            currEnd = maxEnd;\n        }\n    }\n\n    return jumps;\n};",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "H-Index",
            "link": "https://leetcode.com/problems/h-index/",
            "hints": "Create an array to keep track of the number of papers for each number of citations.\nIterate through the count array in reverse and keep the sum of the number of papers published.\nIf the number of papers published is greater than or equal to the current index, return the index.",
            "code": "var hIndex = function(citations) {\n    const n = citations.length;\n    const paperCountByNumOfCitations = Array(n + 1).fill(0);\n\n    for(const c of citations) {\n        if(c >= n) {\n            paperCountByNumOfCitations[n]++;\n        }\n        else {\n            paperCountByNumOfCitations[c]++;\n        }\n    }\n\n    let publishCount = 0;\n    for(let h = n; h >= 0; h--) {\n        publishCount += paperCountByNumOfCitations[h];\n        if(publishCount >= h) {\n            return h;\n        }\n    }\n\n    return 0;\n};",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Insert Delete GetRandom O(1)",
            "link": "https://leetcode.com/problems/insert-delete-getrandom-o1/"
          },
          {
            "question": "Product of Array Except Self",
            "link": "https://leetcode.com/problems/product-of-array-except-self/"
          },
          {
            "question": "Gas Station",
            "link": "https://leetcode.com/problems/gas-station/"
          },
          {
            "question": "Candy",
            "link": "https://leetcode.com/problems/candy/"
          },
          {
            "question": "Trapping Rain Water",
            "link": "https://leetcode.com/problems/trapping-rain-water/"
          },
          {
            "question": "Roman to Integer",
            "link": "https://leetcode.com/problems/roman-to-integer/"
          },
          {
            "question": "Integer to Roman",
            "link": "https://leetcode.com/problems/integer-to-roman/"
          },
          {
            "question": "Length of Last Word",
            "link": "https://leetcode.com/problems/length-of-last-word/",
            "code": "var lengthOfLastWord = function(s) {\n    let length = 0;\n    let i = s.length - 1;\n\n    while (i >= 0 && s[i] === ' ') {\n        i--;\n    }\n\n    while (i >= 0 && s[i] !== ' ') {\n        length++;\n        i--;\n    }\n\n    return length;\n};",
            "hints": "Iterate from the end of the string and ignore any trailing spaces.\nCount the length of the last word.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Longest Common Prefix",
            "link": "https://leetcode.com/problems/longest-common-prefix/"
          },
          {
            "question": "Reverse Words in a String",
            "link": "https://leetcode.com/problems/reverse-words-in-a-string/"
          },
          {
            "question": "Zigzag Conversion",
            "link": "https://leetcode.com/problems/zigzag-conversion/"
          },
          {
            "question": "Find the Index of the First Occurrence in a String",
            "link": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",
            "code": "var strStr = function(haystack, needle) {\n    const n1 = haystack.length, n2 = needle.length;\n\n    if(n1 < n2) return -1;\n\n    for(let i = 0; i < n1 ; i++) {\n        let j = 0;\n        while(j < n2 && haystack[j + i] == needle[j]) {\n            j++;\n        }\n        if(j == n2) return i;\n    }\n\n    return -1;\n};",
            "hints": "Iterate through the haystack and compare the substring of the haystack with the needle.\nIf the substring matches the needle, return the index.",
            "complexity": "Time: O(n*m)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Text Justification",
            "link": "https://leetcode.com/problems/text-justification/"
          }
        ]
      },
      {
        "name": "Two Pointers",
        "questions": [
          {
            "question": "Valid Palindrome",
            "link": "https://leetcode.com/problems/valid-palindrome/",
            "code": "var isPalindrome = function(s) {\n    const filtered = s.replaceAll(/[^a-z0-9]/gi, \"\").toLowerCase();\n    const reversed = filtered.split('').reverse().join('');\n    return filtered == reversed;\n};",
            "hints": "Use two pointers, one at the start and one at the end.\nIgnore non-alphanumeric characters and compare the characters.\nOr\nUse regular expressions to filter out non-alphanumeric characters.\nConvert the string to lowercase and compare the filtered string with its reverse.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Easy"
          },
          {
            "question": "Is Subsequence",
            "link": "https://leetcode.com/problems/is-subsequence/",
            "code": "var isSubsequence = function(s, t) {\n    if(s == t) return true;\n    \n    const n = s.length;\n    let k = 0;\n\n    for(const c of t) {\n        if(c == s[k]) {\n            k++;\n        }\n        if(k == n) return true;\n    }\n\n    return false;\n};",
            "hints": "Use two pointers, one for the subsequence and one for the string.\nIf the characters match, increment the subsequence pointer.\nIf the subsequence pointer reaches the end, return true.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Two Sum II - Input Array Is Sorted",
            "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
            "code": "var twoSum = function(numbers, target) {\n    const n = numbers.length;\n\n    let l = 0, r = n - 1;\n\n    while(l < r) {\n        const sum = numbers[l] + numbers[r];\n        if(sum == target) {\n            return [l + 1, r + 1];\n        }\n\n        if(sum < target) {\n            l++;\n        }\n        else {\n            r--;\n        }\n    }\n};",
            "hints": "Use two pointers, one at the start and one at the end.\nIf the sum of the two elements is equal to the target, return the indices.\nIf the sum is less than the target, increment the start pointer, else decrement the end pointer.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Container With Most Water",
            "link": "https://leetcode.com/problems/container-with-most-water/"
          },
          {
            "question": "3Sum",
            "link": "https://leetcode.com/problems/3sum/"
          }
        ]
      },
      {
        "name": "Sliding Window",
        "questions": [
          {
            "question": "Minimum Size Subarray Sum",
            "link": "https://leetcode.com/problems/minimum-size-subarray-sum/"
          },
          {
            "question": "Longest Substring Without Repeating Characters",
            "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
          },
          {
            "question": "Substring with Concatenation of All Words",
            "link": "https://leetcode.com/problems/substring-with-concatenation-of-all-words/"
          },
          {
            "question": "Minimum Window Substring",
            "link": "https://leetcode.com/problems/minimum-window-substring/"
          }
        ]
      },
      {
        "name": "Matrix",
        "questions": [
          {
            "question": "Valid Sudoku",
            "link": "https://leetcode.com/problems/valid-sudoku/"
          },
          {
            "question": "Spiral Matrix",
            "link": "https://leetcode.com/problems/spiral-matrix/"
          },
          {
            "question": "Rotate Image",
            "link": "https://leetcode.com/problems/rotate-image/"
          },
          {
            "question": "Set Matrix Zeroes",
            "link": "https://leetcode.com/problems/set-matrix-zeroes/"
          },
          {
            "question": "Game of Life",
            "link": "https://leetcode.com/problems/game-of-life/"
          }
        ]
      },
      {
        "name": "Hashmap",
        "questions": [
          {
            "question": "Ransom Note",
            "link": "https://leetcode.com/problems/ransom-note/"
          },
          {
            "question": "Isomorphic Strings",
            "link": "https://leetcode.com/problems/isomorphic-strings/"
          },
          {
            "question": "Word Pattern",
            "link": "https://leetcode.com/problems/word-pattern/"
          },
          {
            "question": "Valid Anagram",
            "link": "https://leetcode.com/problems/valid-anagram/",
            "code": "var isAnagram = function(s, t) {\n    return s.split('').sort().join('') == t.split('').sort().join('');\n};",
            "hints": "Sort the characters of both strings and compare them.",
            "complexity": "Time: O(nlogn)\nSpace: O(n)",
            "difficulty": "Easy"
          },
          {
            "question": "Group Anagrams",
            "link": "https://leetcode.com/problems/group-anagrams/",
            "code": "var groupAnagrams = function(strs) {\n    const map = new Map();\n\n    for(const str of strs) {\n        const key = str.split('').sort().join('');\n        if(map.has(key)) {\n            map.set(key, [...map.get(key), str]);\n        }\n        else {\n            map.set(key, [str]);\n        }\n    }\n\n    return [...map.values()];\n};",
            "hints": "Use a hashmap to group anagrams.\nSort the characters of each string and use the sorted string as the key in the hashmap.",
            "complexity": "Time: O(nklogk)\nSpace: O(nk)",
            "difficulty": "Medium"
          },
          {
            "question": "Two Sum",
            "link": "https://leetcode.com/problems/two-sum/",
            "code": "var twoSum = function(nums, target) {\n    const map = new Map(), n = nums.length;\n\n    for(let i = 0; i < n; i++ ) {\n        const searchNum = target - nums[i];\n        if(map.has(searchNum)) {\n            return [map.get(searchNum), i];\n        }\n\n        map.set(nums[i], i);\n    }\n};",
            "hints": "Use a hashmap to store the difference between the target and the current element.\nIf the difference is found in the hashmap, return the indices.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Easy"
          },
          {
            "question": "Happy Number",
            "link": "https://leetcode.com/problems/happy-number/"
          },
          {
            "question": "Contains Duplicate II",
            "link": "https://leetcode.com/problems/contains-duplicate-ii/"
          },
          {
            "question": "Longest Consecutive Sequence",
            "link": "https://leetcode.com/problems/longest-consecutive-sequence/"
          }
        ]
      },
      {
        "name": "Intervals",
        "questions": [
          {
            "question": "Summary Ranges",
            "link": "https://leetcode.com/problems/summary-ranges/",
            "code": "var summaryRanges = function(nums) {\n    const n = nums.length, ans = [];\n\n    if(n == 0) return [];\n\n    let start = nums[0], end = nums[0];\n\n    for(let i = 1; i < n; i++) {\n        const num = nums[i];\n\n        if(num == end + 1) {\n            end = num;\n        }\n        else {\n            if(start == end) {\n                ans.push(`${start}`);\n            }\n            else {\n                ans.push(`${start}->${end}`)\n            }\n            start = num;\n            end = num;\n        }\n    }\n\n    if(start == end) {\n        ans.push(`${start}`);\n    }\n    else {\n        ans.push(`${start}->${end}`)\n    }\n\n    return ans;\n};",
            "hints": "Iterate through the array and keep track of the start and end of the range.\nIf the current number is not part of the range, add the range to the answer.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Easy"
          },
          {
            "question": "Merge Intervals",
            "link": "https://leetcode.com/problems/merge-intervals/",
            "code": "var merge = function(intervals) {\n    const sorted = intervals.sort((a, b) => {\n        if(a[0] == b[0]) return a[1] - b[1];\n        return a[0] - b[0];\n    });\n\n    const n = sorted.length, ans = [];\n    let [currStart, currEnd] = [sorted[0][0], sorted[0][1]];\n\n    for(let i = 1; i < n; i++) {\n        const [start, end] = sorted[i];\n\n        if(end > currEnd) {\n            if(start > currEnd) {\n                ans.push([currStart, currEnd]);\n                currStart = start;\n                currEnd = end;\n            }\n            else {\n                currEnd = end;\n            }\n        }\n    }\n\n    ans.push([currStart, currEnd]);\n    return ans;\n};",
            "hints": "Sort the intervals based on the start time.\nIterate through the intervals and merge overlapping intervals.\nCompare the end time of current interval with previous interval to check for cases where the previous interval completely overlaps the current interval,\nand then compare the start time of the current interval with the end time of the previous interval.",
            "complexity": "Time: O(nlogn)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Insert Interval",
            "link": "https://leetcode.com/problems/insert-interval/"
          },
          {
            "question": "Minimum Number of Arrows to Burst Balloons",
            "link": "https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/"
          }
        ]
      },
      {
        "name": "Stack",
        "questions": [
          {
            "question": "Valid Parentheses",
            "link": "https://leetcode.com/problems/valid-parentheses/",
            "code": "var isValid = function(s) {\n    const stack = [];\n\n    for(const c of s) {\n        if(c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        }\n        else {\n            if(stack.length == 0) return false;\n            const top = stack[stack.length - 1];\n\n            switch(c) {\n                case ')': {\n                    if(top == '(') stack.pop();\n                    else return false;\n                    break;\n                }\n                case '}': {\n                    if(top == '{') stack.pop();\n                    else return false;\n                    break;\n                }\n                case ']': {\n                    if(top == '[') stack.pop();\n                    else return false;\n                    break;\n                }\n            }\n        }\n    }\n\n    return stack.length == 0;\n};",
            "hints": "Use a stack to keep track of the opening brackets.\nIf the current character is an opening bracket, push it onto the stack.\nIf the current character is a closing bracket, check if the stack is empty or the top of the stack is not the corresponding opening bracket.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Easy"
          },
          {
            "question": "Simplify Path",
            "link": "https://leetcode.com/problems/simplify-path/"
          },
          {
            "question": "Min Stack",
            "link": "https://leetcode.com/problems/min-stack/",
            "code": "var MinStack = function() {\n    this.stack = [];\n    this.minStack = [];\n};\n\nMinStack.prototype.push = function(val) {\n    this.stack.push(val);\n    if(this.minStack.length == 0) {\n        this.minStack.push(val);\n    }\n    else {\n        const top = this.getMin();\n        if(val < top) {\n            this.minStack.push(val);\n        }\n        else {\n            this.minStack.push(top);\n        }\n    }\n};\n\nMinStack.prototype.pop = function() {\n    if(this.minStack.length == 0) return;\n    \n    this.stack.pop();\n    this.minStack.pop();\n};\n\nMinStack.prototype.top = function() {\n    return this.stack[this.stack.length - 1] || null;\n};\n\nMinStack.prototype.getMin = function() {\n    return this.minStack[this.minStack.length - 1] || null;\n};",
            "hints": "Use two stacks, one to keep track of the elements and the other to keep track of the minimum element.\nWhen pushing an element, compare it with the top of the minimum stack and push the smaller element onto the minimum stack.",
            "complexity": "Time: O(1)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Evaluate Reverse Polish Notation",
            "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
          },
          {
            "question": "Basic Calculator",
            "link": "https://leetcode.com/problems/basic-calculator/"
          }
        ]
      },
      {
        "name": "Linked List",
        "questions": [
          {
            "question": "Linked List Cycle",
            "link": "https://leetcode.com/problems/linked-list-cycle/",
            "code": "var hasCycle = function(head) {\n    let slow = head, fast = head?.next;\n\n    while(fast != null) {\n        if(slow == fast) {\n            return true;\n        }\n\n        slow = slow.next;\n        fast = fast.next?.next;\n    }\n\n    return false;\n};",
            "hints": "Use two pointers, one slow and one fast.\nIf there is a cycle, the two pointers will meet at some point.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Add Two Numbers",
            "link": "https://leetcode.com/problems/add-two-numbers/",
            "code": "var addTwoNumbers = function(l1, l2) {\n    const dummyHead = new ListNode(0);\n    let c1 = l1, c2 = l2, c3 = dummyHead, carry = 0, rem = 0;\n\n    while(c1 != null && c2 != null) {\n        const sum = c1.val + c2.val + carry;\n        carry = Math.trunc(sum / 10);\n        rem = Math.trunc(sum % 10);\n        c3.next = new ListNode(rem);\n        c3 = c3.next;\n        c1 = c1.next;\n        c2 = c2.next;\n    }\n\n    let remainingList = c1 == null ? c2 : c1;\n\n    while(remainingList != null) {\n        const sum = remainingList.val + carry;\n        carry = Math.trunc(sum / 10);\n        rem = Math.trunc(sum % 10);\n        c3.next = new ListNode(rem);\n        c3 = c3.next;\n        remainingList = remainingList.next;\n    }\n\n    if(carry) {\n        c3.next = new ListNode(carry);\n    }\n\n    return dummyHead.next;\n};",
            "hints": "Create a dummy node to keep track of the head of the new linked list.\nIterate through the two linked lists and add the values.\nKeep track of the carry and the remainder.\nCreate a new node with the remainder and update the carry.\nIf there are any remaining nodes, add them to the new linked list.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Merge Two Sorted Lists",
            "link": "https://leetcode.com/problems/merge-two-sorted-lists/",
            "code": "var mergeTwoLists = function(list1, list2) {\n    let dummyHead = new ListNode(0), c1 = list1, c2 = list2, c3 = dummyHead;\n\n    while(c1 != null && c2 != null) {\n        if(c1.val < c2.val) {\n            c3.next = c1;\n            c1 = c1.next;\n        }\n        else {\n            c3.next = c2;\n            c2 = c2.next;\n        }\n        c3 = c3.next;\n    }\n\n    if(c1 != null) {\n        c3.next = c1;\n    }\n    else {\n        c3.next = c2;\n    }\n\n    return dummyHead.next;\n};",
            "hints": "Create a dummy node to keep track of the head of the new linked list.\nIterate through the two linked lists and compare the values.\nAdd the smaller value to the new linked list and update the pointer.\nIf there are any remaining nodes, add them to the new linked list.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Copy List with Random Pointer (Extra Space)",
            "link": "https://leetcode.com/problems/copy-list-with-random-pointer/",
            "code": "var copyRandomList = function(head) {\n    if(head == null) return null;\n    \n    let curr = head;\n    const cloneMap = new Map();\n\n    while(curr != null) {\n        const cloneNode = new Node(curr.val);\n        cloneMap.set(curr, cloneNode);\n        curr = curr.next;\n    }\n\n    curr = head;\n\n    while(curr != null) {\n        const cloneNode = cloneMap.get(curr);\n        cloneNode.next = cloneMap.get(curr.next) || null;\n        cloneNode.random = cloneMap.get(curr.random) || null;\n        curr = curr.next;\n    }\n\n    return cloneMap.get(head);\n};",
            "hints": "Use a hashmap, where the key is the original node and the value is the clone node.\nIterate through the linked list and create a clone node for each node.\nUpdate the next and random pointers of the clone node using the hashmap.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Copy List with Random Pointer",
            "link": "https://leetcode.com/problems/copy-list-with-random-pointer/",
            "code": "var copyRandomList = function(head) {\n    if(head == null) return null;\n    \n    let curr = head;\n\n    while(curr != null) {\n        const cloneNode = new ListNode(curr.val);\n        const next = curr.next;\n        curr.next = cloneNode;\n        cloneNode.next = next;\n        curr = next;\n    }\n\n    curr = head;\n    const newList = head.next;\n\n    while(curr != null) {\n        const next = curr.next.next;\n        if(curr.random) {\n            curr.next.random = curr.random.next;\n        }\n        curr = next;\n    }\n\n    curr = head;\n\n    while(curr != null) {\n        const next = curr.next.next;\n        if(next) {\n            curr.next.next = next.next;\n        }\n        curr.next = next;\n        curr = next;\n    }\n    \n    return newList;\n};",
            "hints": "Iterate through the linked list and create a clone node for each node.\nUpdate the next pointer of the original node to the clone node.\nIterate through the linked list and update the random pointer of the clone node.\nIterate through the linked list and update the next pointer of the original node and the clone node.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Reverse Linked List II",
            "link": "https://leetcode.com/problems/reverse-linked-list-ii/",
            "code": "var reverseBetween = function(head, left, right) {\n    if(head == null) return null;\n    const stack = Array(), dummyHead = new ListNode(0);\n    let curr = head, prev = dummyHead, i = 1;\n    prev.next = head;\n\n    while(i <= left - 1) {\n        prev = prev.next;\n        i++;\n    }\n\n    curr = prev.next;\n    i = 1;\n\n    while(i <= (right - left + 1)) {\n        stack.push(curr);\n        curr = curr.next;\n        i++\n    }\n\n    while(stack.length > 0) {\n        prev.next = stack.pop();\n        prev = prev.next;\n    }\n\n    prev.next = curr;\n\n    return dummyHead.next;\n};",
            "hints": "Use a stack to store the nodes between left and right.\nIterate through the linked list and update the next pointer of the previous node to the top of the stack.\nUpdate the next pointer of the last node in the stack to the current node.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Reverse Nodes in k-Group",
            "link": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
            "difficulty": "Hard"
          },
          {
            "question": "Remove Nth Node From End of List",
            "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
            "code": "var removeNthFromEnd = function(head, n) {\n    let delay = n, dummyHead = new ListNode(0), delayedPtr = dummyHead, curr = head;\n    dummyHead.next = head;\n\n    while(curr != null) {\n        if(delay-- <= 0) {\n            delayedPtr = delayedPtr.next;\n        }\n        curr = curr.next;\n    }\n\n    delayedPtr.next = delayedPtr.next.next;\n\n    return dummyHead.next;\n};",
            "hints": "Use two pointers, one to keep track of the delayed node and the other to iterate through the linked list.\nMove the delayed pointer when the delay is less than or equal to 0.\nRemove the node by updating the next pointer of the delayed node.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Remove Duplicates from Sorted List II",
            "link": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/",
            "code": "var deleteDuplicates = function(head) {\n    if(head == null) return null;\n    const dummyHead = new ListNode(0);\n    let prev = dummyHead, curr = head, nextPtr = head.next;\n\n    while(curr != null) {\n        while(nextPtr != null && nextPtr.val == curr.val) {\n            nextPtr = nextPtr.next;\n        }\n        \n        if(nextPtr == curr.next) {\n            prev.next = curr;\n            prev = prev.next;\n        }\n\n        curr = nextPtr;\n    }\n\n    prev.next = null;\n    return dummyHead.next;\n};",
            "hints": "Use a dummy node to keep track of the head of the new linked list.\nKeep track of the previous node, the current node, and the next node.\nIterate through the linked list and use next node to find the next distinct node.\nIf the next node is the next node of the current node, add the current node to the new linked list.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Rotate List",
            "link": "https://leetcode.com/problems/rotate-list/",
            "code": "var listLength = function(head) {\n    let count = 0, curr = head;\n\n    while(curr != null) {\n        count++;\n        curr = curr.next;\n    }\n\n    return count;\n}\n\nvar rotateRight = function(head, k) {\n    if(head == null) return null;\n\n    const n = listLength(head);\n    let modK = Math.trunc(k % n);\n    if(modK == 0) return head;\n    \n    let curr = head;\n\n    for(let i = 1; i < n - modK; i++) {\n        curr = curr.next;\n    }\n\n    const newHead = curr.next;\n    curr.next = null;\n\n    curr = newHead;\n    while(curr.next != null) {\n        curr = curr.next;\n    }\n    curr.next = head;\n\n    return newHead;\n};",
            "hints": "Find the length of the linked list.\nCalculate the effective rotation by taking the modulo of k with the length of the linked list.\nIterate through the linked list to find the new head and the new tail.\nUpdate the next pointer of the new tail to the original head and update the next pointer of the new head to null.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Partition List",
            "link": "https://leetcode.com/problems/partition-list/",
            "code": "var partition = function(head, x) {\n    if(head == null) return null;\n    const dummyLessHead = new ListNode(0), dummyGreaterHead = new ListNode(0);\n    let curr = head, lessPrev = dummyLessHead, greaterPrev = dummyGreaterHead;\n\n    while(curr != null) {\n        if(curr.val < x) {\n            lessPrev.next = curr;\n            lessPrev = curr;\n        }\n        else {\n            greaterPrev.next = curr;\n            greaterPrev = curr;\n        }\n        curr = curr.next;\n    }\n\n    greaterPrev.next = null;\n    lessPrev.next = dummyGreaterHead.next;\n    return dummyLessHead.next;\n};",
            "hints": "Create two dummy nodes to keep track of the head of the less than and greater than linked lists.\nIterate through the linked list and add the nodes to the respective linked lists.\nUpdate the next pointer of the greater than linked list to null and the next pointer of the less than linked list to the greater than linked list.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "LRU Cache",
            "link": "https://leetcode.com/problems/lru-cache/"
          }
        ]
      },
      {
        "name": "Binary Tree General",
        "questions": [
          {
            "question": "Maximum Depth of Binary Tree",
            "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
            "code": "var maxDepth = function(root) {\n    if(root == null) return 0;\n\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n};",
            "hints": "Recursively calculate the maximum depth of the left and right subtrees.\nReturn 1 plus the maximum depth of the left and right subtrees.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Same Tree",
            "link": "https://leetcode.com/problems/same-tree/",
            "code": "var isSameTree = function(p, q) {\n    if(p == null && q == null) return true;\n    if(p == null || q == null) return false;\n    if(p.val != q.val) return false;\n\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n};",
            "hints": "Recursively check if the current nodes are equal.\nRecursively check if the left subtrees are equal.\nRecursively check if the right subtrees are equal.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Invert Binary Tree",
            "link": "https://leetcode.com/problems/invert-binary-tree/",
            "code": "var invertTree = function(root) {\n    if(root == null) return null;\n    \n    const leftSubtree = invertTree(root.left);\n    const rightSubtree = invertTree(root.right);\n    root.left = rightSubtree;\n    root.right = leftSubtree;\n\n    return root;\n};",
            "hints": "Recursively invert the left and right subtrees.\nSwap the left and right subtrees.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Symmetric Tree",
            "link": "https://leetcode.com/problems/symmetric-tree/",
            "code": "var isSymmetric = function(root) {\n    if(root == null) return true;\n    return isSymmetricUtil(root.left, root.right);\n};\n\nvar isSymmetricUtil = function(rootA, rootB) {\n    if(rootA == null && rootB == null) return true;\n    if(rootA == null || rootB == null) return false;\n    if(rootA.val != rootB.val) return false;\n\n    return isSymmetricUtil(rootA.left, rootB.right) && isSymmetricUtil(rootA.right, rootB.left);\n};",
            "hints": "Recursively check if the left and right subtrees are symmetric.\nCheck if the left subtree of the left subtree is equal to the right subtree of the right subtree.\nCheck if the right subtree of the left subtree is equal to the left subtree of the right subtree.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Construct Binary Tree from Preorder and Inorder Traversal",
            "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
            "code": "var buildTree = function(preorder, inorder) {\n    return buildTreeUtil(preorder, inorder, [0]);\n};\n\nvar buildTreeUtil = function(preorder, inorder, preIndex) {\n    if(preIndex >= preorder.length) return null;\n\n    const curr = preorder[preIndex[0]];\n    const inorderIndex = inorder.findIndex(ele => ele == curr);\n    if(inorderIndex == -1) return null;\n\n    preIndex[0]++;\n\n    const root = new TreeNode(curr);\n    root.left = buildTreeUtil(preorder, inorder.slice(0, inorderIndex), preIndex);\n    root.right = buildTreeUtil(preorder, inorder.slice(inorderIndex), preIndex);\n\n    return root;\n}",
            "hints": "Use a preorder traversal to get the current node.\nFind the index of the current node in the inorder traversal.\nRecursively build the left subtree with the left part of the inorder traversal.\nRecursively build the right subtree with the right part of the inorder traversal.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Construct Binary Tree from Inorder and Postorder Traversal",
            "link": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
            "code": "var buildTree = function(inorder, postorder) {\n    return buildTreeUtil(inorder, postorder, [postorder.length - 1]);\n};\n\nvar buildTreeUtil = function(inorder, postorder, postIndex) {\n    if(postIndex < 0) return null;\n\n    const curr = postorder[postIndex[0]];\n    const inorderIndex = inorder.findIndex(ele => ele == curr);\n    if(inorderIndex == -1) return null;\n\n    postIndex[0]--;\n\n    const root = new TreeNode(curr);\n    root.right = buildTreeUtil(inorder.slice(inorderIndex), postorder, postIndex);\n    root.left = buildTreeUtil(inorder.slice(0, inorderIndex), postorder, postIndex);\n\n    return root;\n}",
            "hints": "Use a postorder traversal to get the current node.\nFind the index of the current node in the inorder traversal.\nRecursively build the right subtree with the right part of the inorder traversal.\nRecursively build the left subtree with the left part of the inorder traversal.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Populating Next Right Pointers in Each Node",
            "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/",
            "code": "var connect = function(root) {\n    let levelStart = root;\n\n    while(levelStart != null) {\n        let curr = levelStart;\n\n        while(curr != null) {\n            if(curr.left != null) {\n                curr.left.next = curr.right;\n            }\n            if(curr.next != null && curr.right != null) {\n                curr.right.next = curr.next.left;\n            }\n            curr = curr.next;\n        }\n\n        levelStart = levelStart.left;\n    }\n\n    return root;\n};",
            "hints": "Use a level order traversal to connect the nodes at the same level.\nIterate through the nodes at the same level and connect the left and right nodes.\nIf the current node has a next node, connect the right node of the current node to the left node of the next node.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Populating Next Right Pointers in Each Node II",
            "link": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/",
            "code": "var connect = function(root) {\n    let levelStart = root;\n\n    while(levelStart != null) {\n        let curr = levelStart;\n\n        while(curr != null) {\n            if(curr.left != null) {\n                if(curr.right) {\n                    curr.left.next = curr.right;\n                }\n                else {\n                    curr.left.next = getNextNeighbour(curr.next);\n                }\n            }\n            if(curr.right != null) {\n                curr.right.next = getNextNeighbour(curr.next);\n            }\n            curr = curr.next;\n        }\n\n        levelStart = levelStart.left || levelStart.right || levelStart.next;\n    }\n\n    return root;\n};\n\nvar getNextNeighbour = function(root) {\n    let curr = root;\n\n    while(curr != null) {\n        if(curr.left != null) {\n            return curr.left;\n        }\n        else if(curr.right != null) {\n            return curr.right;\n        }\n        curr = curr.next;\n    }\n\n    return null;\n}",
            "hints": "Use a level order traversal to connect the nodes at the same level.\nIterate through the nodes at the same level and connect the left and right nodes.\nIf the current node has a next node, connect the right node of the current node to the left node of the next node.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Flatten Binary Tree to Linked List",
            "link": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
            "code": "var prev = null;\n\nvar flatten = function(root) {\n    prev = null;\n    flattenUtil(root);\n};\n\nvar flattenUtil = function(root) {\n    if(root == null) return null;\n\n    flattenUtil(root.right);\n    flattenUtil(root.left);\n\n    root.right = prev;\n    root.left = null;\n    prev = root;\n}",
            "hints": "Use a postorder traversal to flatten the binary tree.\nRecursively flatten the right subtree.\nRecursively flatten the left subtree.\nUpdate the right pointer of the current node to the previous node.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Path Sum",
            "link": "https://leetcode.com/problems/path-sum/",
            "code": "var hasPathSum = function(root, targetSum) {\n    if(root == null) return false;\n\n    const newSum = targetSum - root.val;\n    if(newSum == 0 && root.left == null && root.right == null) return true;\n\n    const left = hasPathSum(root.left, newSum);\n    const right = hasPathSum(root.right, newSum);\n\n    return left || right;\n};",
            "hints": "Recursively check if the current node is a leaf node and the sum is equal to the target sum.\nRecursively check if the left subtree has a path sum equal to the target sum.\nRecursively check if the right subtree has a path sum equal to the target sum.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Sum Root to Leaf Numbers",
            "link": "https://leetcode.com/problems/sum-root-to-leaf-numbers/",
            "code": "var sumNumbers = function(root) {\n    if(root == null) return 0;\n\n    return sumNumbersUtil(root, \"\");\n};\n\nvar sumNumbersUtil = function(root, currNum) {\n    if(root == null) return 0;\n\n    const newNum = currNum + root.val;\n\n    if(root.left == null && root.right == null) {\n        return Number(newNum);\n    }\n\n    const left = sumNumbersUtil(root.left, newNum);\n    const right = sumNumbersUtil(root.right, newNum);\n\n    return Number(left) + Number(right);\n}",
            "hints": "Recursively calculate the sum of the numbers from the root to the leaf nodes.\nIf the current node is a leaf node, return the number.\nRecursively calculate the sum of the numbers from the left and right subtrees.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Binary Tree Maximum Path Sum",
            "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
          },
          {
            "question": "Binary Search Tree Iterator",
            "link": "https://leetcode.com/problems/binary-search-tree-iterator/"
          },
          {
            "question": "Count Complete Tree Nodes",
            "link": "https://leetcode.com/problems/count-complete-tree-nodes/"
          },
          {
            "question": "Lowest Common Ancestor of a Binary Tree",
            "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
            "code": "var lowestCommonAncestor = function(root, p, q) {\n    if(root == null) return null;\n    if(root == p || root == q) return root;\n\n    const leftLCA = lowestCommonAncestor(root.left, p, q);\n    const rightLCA = lowestCommonAncestor(root.right, p, q);\n\n    if(leftLCA != null && rightLCA != null) return root;\n\n    return leftLCA != null ? leftLCA : rightLCA;\n};",
            "hints": "Recursively check if the current node is one of the nodes.\nRecursively find the lowest common ancestor in the left subtree.\nRecursively find the lowest common ancestor in the right subtree.\nIf the left and right subtrees have the nodes, return the current node.",
            "complexity": "Time: O(n)\nSpace: O(1)",
            "difficulty": "Medium"
          }
        ]
      },
      {
        "name": "Binary Tree BFS",
        "questions": [
          {
            "question": "Binary Tree Right Side View",
            "link": "https://leetcode.com/problems/binary-tree-right-side-view/",
            "code": "var rightSideView = function(root) {\n    if(root == null) return [];\n\n    const queue = [root];\n    const rightView = [];\n\n    while(queue.length > 0){\n        let size = queue.length;\n        const lastEle = queue[queue.length - 1];\n        rightView.push(lastEle.val);\n        while(size-- > 0) {\n            let curr = queue.shift();\n            if(curr.left) queue.push(curr.left);\n            if(curr.right) queue.push(curr.right);\n        }\n    }\n\n    return rightView;\n};",
            "hints": "Use a queue to perform a level order traversal.\nKeep track of the last element in each level.\nAdd the last element to the right view array.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Average of Levels in Binary Tree",
            "link": "https://leetcode.com/problems/average-of-levels-in-binary-tree/"
          },
          {
            "question": "Binary Tree Level Order Traversal",
            "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
            "code": "var levelOrder = function(root) {\n    if(root == null) return [];\n\n    const queue = [root], levelOrder = [];\n\n    while(queue.length > 0){\n        let size = queue.length;\n        levelOrder.push(queue.map(node => node.val));\n        \n        while(size-- > 0) {\n            let curr = queue.shift();\n            if(curr.left) queue.push(curr.left);\n            if(curr.right) queue.push(curr.right);\n        }\n    }\n\n    return levelOrder;\n};",
            "hints": "Use a queue to perform a level order traversal.\nKeep track of the nodes at each level.\nAdd the nodes at each level to the level order array.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Binary Tree Zigzag Level Order Traversal",
            "link": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
            "code": "var zigzagLevelOrder = function(root) {\n    if(root == null) return [];\n\n    const queue = [root], levelOrder = [];\n    let level = 0;\n\n    while(queue.length > 0){\n        let size = queue.length;\n        const currLevel = queue.map(node => node.val);\n        levelOrder.push((level & 1 == 1) ? currLevel.reverse() : currLevel);\n\n        while(size-- > 0) {\n            let curr = queue.shift();\n            if(curr.left) queue.push(curr.left);\n            if(curr.right) queue.push(curr.right);\n        }\n        level++;\n    }\n\n    return levelOrder;\n};",
            "hints": "Use a queue to perform a level order traversal.\nKeep track of the level to determine the direction of traversal.\nReverse the nodes at each level based on the level.",
            "complexity": "Time: O(n)\nSpace: O(n)",
            "difficulty": "Medium"
          }
        ]
      },
      {
        "name": "Binary Search Tree",
        "questions": [
          {
            "question": "Minimum Absolute Difference in BST",
            "link": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/"
          },
          {
            "question": "Kth Smallest Element in a BST",
            "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
          },
          {
            "question": "Validate Binary Search Tree",
            "link": "https://leetcode.com/problems/validate-binary-search-tree/"
          }
        ]
      },
      {
        "name": "Graph General",
        "questions": [
          {
            "question": "Number of Islands",
            "link": "https://leetcode.com/problems/number-of-islands/"
          },
          {
            "question": "Surrounded Regions",
            "link": "https://leetcode.com/problems/surrounded-regions/"
          },
          {
            "question": "Clone Graph",
            "link": "https://leetcode.com/problems/clone-graph/"
          },
          {
            "question": "Evaluate Division",
            "link": "https://leetcode.com/problems/evaluate-division/"
          },
          {
            "question": "Course Schedule",
            "link": "https://leetcode.com/problems/course-schedule/"
          },
          {
            "question": "Course Schedule II",
            "link": "https://leetcode.com/problems/course-schedule-ii/"
          }
        ]
      },
      {
        "name": "Graph BFS",
        "questions": [
          {
            "question": "Snakes and Ladders",
            "link": "https://leetcode.com/problems/snakes-and-ladders/"
          },
          {
            "question": "Minimum Genetic Mutation",
            "link": "https://leetcode.com/problems/minimum-genetic-mutation/"
          },
          {
            "question": "Word Ladder",
            "link": "https://leetcode.com/problems/word-ladder/"
          }
        ]
      },
      {
        "name": "Trie",
        "questions": [
          {
            "question": "Implement Trie (Prefix Tree)",
            "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
          },
          {
            "question": "Design Add and Search Words Data Structure",
            "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
          },
          {
            "question": "Word Search II",
            "link": "https://leetcode.com/problems/word-search-ii/"
          }
        ]
      },
      {
        "name": "Backtracking",
        "questions": [
          {
            "question": "Letter Combinations of a Phone Number",
            "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/"
          },
          {
            "question": "Combinations",
            "link": "https://leetcode.com/problems/combinations/"
          },
          {
            "question": "Permutations",
            "link": "https://leetcode.com/problems/permutations/"
          },
          {
            "question": "Combination Sum",
            "link": "https://leetcode.com/problems/combination-sum/"
          },
          {
            "question": "N-Queens II",
            "link": "https://leetcode.com/problems/n-queens-ii/"
          },
          {
            "question": "Generate Parentheses",
            "link": "https://leetcode.com/problems/generate-parentheses/"
          },
          {
            "question": "Word Search",
            "link": "https://leetcode.com/problems/word-search/"
          }
        ]
      },
      {
        "name": "Divide and Conquer",
        "questions": [
          {
            "question": "Convert Sorted Array to Binary Search Tree",
            "link": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/"
          },
          {
            "question": "Sort List",
            "link": "https://leetcode.com/problems/sort-list/"
          },
          {
            "question": "Construct Quad Tree",
            "link": "https://leetcode.com/problems/construct-quad-tree/"
          },
          {
            "question": "Merge k Sorted Lists",
            "link": "https://leetcode.com/problems/merge-k-sorted-lists/"
          }
        ]
      },
      {
        "name": "Kadane's Algorithm",
        "questions": [
          {
            "question": "Maximum Subarray",
            "link": "https://leetcode.com/problems/maximum-subarray/"
          },
          {
            "question": "Maximum Sum Circular Subarray",
            "link": "https://leetcode.com/problems/maximum-sum-circular-subarray/"
          }
        ]
      },
      {
        "name": "Binary Search",
        "questions": [
          {
            "question": "Search Insert Position",
            "link": "https://leetcode.com/problems/search-insert-position/",
            "code": "var searchInsert = function(nums, target) {\n    const n = nums.length;\n\n    let l = 0, r = n;\n\n    while(l < r) {\n        const mid = parseInt(l + (r - l) / 2);\n        \n        if(target == nums[mid]) {\n            return mid;\n        }\n\n        if(target > nums[mid]) {\n            l = mid + 1;\n        }\n        else {\n            r = mid;\n        }\n    }\n\n    return l;\n};",
            "hints": "Use binary search to find the target element.\nIf the target element is not found, return the left pointer.",
            "complexity": "Time: O(log n)\nSpace: O(1)",
            "difficulty": "Easy"
          },
          {
            "question": "Search a 2D Matrix",
            "link": "https://leetcode.com/problems/search-a-2d-matrix/",
            "code": "var searchMatrix = function(matrix, target) {\n    const m = matrix.length, n = matrix[0].length;\n\n    let l = 0, r = m * n - 1;\n\n    while(l <= r) {\n        const mid = parseInt(l + (r - l) / 2);\n        const row = parseInt(mid / n);\n        const col = mid % n;\n        const ele = matrix[row][col];\n\n        if(ele == target) return true;\n        \n        if(ele > target) {\n            r = mid - 1;\n        }\n        else {\n            l = mid + 1;\n        }\n    }\n\n    return false;\n};",
            "hints": "Use binary search to find the target element.\nConvert the 2D matrix to a 1D array and find the row and column of the mid element.",
            "complexity": "Time: O(log(m * n))\nSpace: O(1)",
            "difficulty": "Medium"
          },
          {
            "question": "Find Peak Element",
            "link": "https://leetcode.com/problems/find-peak-element/"
          },
          {
            "question": "Search in Rotated Sorted Array",
            "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
          },
          {
            "question": "Find First and Last Position of Element in Sorted Array",
            "link": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
          },
          {
            "question": "Find Minimum in Rotated Sorted Array",
            "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
          },
          {
            "question": "Median of Two Sorted Arrays",
            "link": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
          }
        ]
      },
      {
        "name": "Heap",
        "questions": [
          {
            "question": "Kth Largest Element in an Array",
            "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
          },
          {
            "question": "IPO",
            "link": "https://leetcode.com/problems/ipo/"
          },
          {
            "question": "Find K Pairs with Smallest Sums",
            "link": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/"
          },
          {
            "question": "Find Median from Data Stream",
            "link": "https://leetcode.com/problems/find-median-from-data-stream/"
          }
        ]
      },
      {
        "name": "Bit Manipulation",
        "questions": [
          {
            "question": "Add Binary",
            "link": "https://leetcode.com/problems/add-binary/"
          },
          {
            "question": "Reverse Bits",
            "link": "https://leetcode.com/problems/reverse-bits/"
          },
          {
            "question": "Number of 1 Bits",
            "link": "https://leetcode.com/problems/number-of-1-bits/"
          },
          {
            "question": "Single Number",
            "link": "https://leetcode.com/problems/single-number/"
          },
          {
            "question": "Single Number II",
            "link": "https://leetcode.com/problems/single-number-ii/"
          },
          {
            "question": "Bitwise AND of Numbers Range",
            "link": "https://leetcode.com/problems/bitwise-and-of-numbers-range/"
          }
        ]
      },
      {
        "name": "Math",
        "questions": [
          {
            "question": "Palindrome Number",
            "link": "https://leetcode.com/problems/palindrome-number/"
          },
          {
            "question": "Plus One",
            "link": "https://leetcode.com/problems/plus-one/"
          },
          {
            "question": "Factorial Trailing Zeroes",
            "link": "https://leetcode.com/problems/factorial-trailing-zeroes/"
          },
          {
            "question": "Sqrt(x)",
            "link": "https://leetcode.com/problems/sqrtx/"
          },
          {
            "question": "Pow(x, n)",
            "link": "https://leetcode.com/problems/powx-n/"
          },
          {
            "question": "Max Points on a Line",
            "link": "https://leetcode.com/problems/max-points-on-a-line/"
          }
        ]
      },
      {
        "name": "Dynamic Programming",
        "questions": [
          {
            "question": "Climbing Stairs",
            "link": "https://leetcode.com/problems/climbing-stairs/"
          },
          {
            "question": "House Robber",
            "link": "https://leetcode.com/problems/house-robber/"
          },
          {
            "question": "Word Break",
            "link": "https://leetcode.com/problems/word-break/",
            "code": "var wordBreak = function(s, wordDict) {\n    const wordSet = new Set();\n    for(let word of wordDict) {\n        wordSet.add(word);\n    }\n\n    const memo = new Map();\n    return backtrack(s, wordSet, memo);\n};\n\nvar backtrack = function(str, wordSet, memo) {\n    if(memo.has(str)) return memo.get(str);\n    \n    if(str == '') return true;\n\n    for(let i = str.length; i > 0; i--) {\n        const subStr = str.substring(0, i);\n        if(wordSet.has(subStr)) {\n            const remStr = str.substring(i);\n            const remBacktrack = backtrack(remStr, wordSet, memo);\n            if (remBacktrack) {\n                memo.set(remStr, true);\n                return true;\n            }\n        }\n    }\n\n    memo.set(str, false);\n    return false;\n}",
            "hints": "Use a recursive function to check if the string can be broken into words.\nUse memoization to store the results of the subproblems.\nIterate through the string and check if the substring is in the word set.",
            "complexity": "Time: O(n^2)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Coin Change",
            "link": "https://leetcode.com/problems/coin-change/",
            "code": "var coinChange = function(coins, amount) {\n    const memo = Array(amount);\n    const ans = backtrack(coins, amount, memo);\n    return ans == Infinity ? -1 : ans;\n};\n\nvar backtrack = function(coins, amount, memo) {\n    if(amount == 0) return 0;\n    if(amount < 0) return Infinity;\n\n    if(memo[amount]) return memo[amount];\n\n    let minCoins = Infinity;\n\n    for(let c of coins) {\n        minCoins = Math.min(minCoins, 1 + backtrack(coins, amount - c, memo));\n    }\n\n    return memo[amount] = minCoins;\n}",
            "hints": "Use a recursive function to find the minimum number of coins required to make the amount.\nUse memoization to store the results of the subproblems.\nIterate through the coins and find the minimum number of coins required to make the amount.",
            "complexity": "Time: O(n * m)\nSpace: O(n)",
            "difficulty": "Medium"
          },
          {
            "question": "Longest Increasing Subsequence",
            "link": "https://leetcode.com/problems/longest-increasing-subsequence/"
          }
        ]
      },
      {
        "name": "Multidimensional Dynamic Programming",
        "questions": [
          {
            "question": "Triangle",
            "link": "https://leetcode.com/problems/triangle/"
          },
          {
            "question": "Minimum Path Sum",
            "link": "https://leetcode.com/problems/minimum-path-sum/"
          },
          {
            "question": "Unique Paths II",
            "link": "https://leetcode.com/problems/unique-paths-ii/"
          },
          {
            "question": "Longest Palindromic Substring",
            "link": "https://leetcode.com/problems/longest-palindromic-substring/"
          },
          {
            "question": "Interleaving String",
            "link": "https://leetcode.com/problems/interleaving-string/"
          },
          {
            "question": "Edit Distance",
            "link": "https://leetcode.com/problems/edit-distance/"
          },
          {
            "question": "Best Time to Buy and Sell Stock III",
            "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/"
          },
          {
            "question": "Best Time to Buy and Sell Stock IV",
            "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/"
          },
          {
            "question": "Maximal Square",
            "link": "https://leetcode.com/problems/maximal-square/"
          }
        ]
      }
    ]
  }
  